name: bundle ASH script(s), and push to new branch
# By https://github.com/fredg1

env:
  # Branch names.
  
  # To have the target branch name use DYNAMIC_TARGET_NAME, set USE_DYNAMIC_TARGET_NAME to 'true'. Will otherwise use STATIC_TARGET_NAME.
  # (doesn't need to be the name of an existing branch. Will create one if needed)
  USE_DYNAMIC_TARGET_NAME: 'false'
  STATIC_TARGET_NAME: 'Pre-Release'
  # in DYNAMIC_TARGET_NAME, {0} will be replaced by the current branch/tag's actual name
  DYNAMIC_TARGET_NAME: 'Bundled-{0}'
  
  
  
  # The path to take (folders to go through) to reach the "mafia folder" in both branches.
  # RELATIVE paths only (relative to the root of the repository).
  # Empty string if it is reachable from the root.
  
  # Only its content will be transferred to <target_branch>
  SOURCE_PATH_TO_MAFIA: 'Source'
  
  # If this folder already exists on the target branch, IT'S CONTENT WILL BE ERASED.
  # Stuff outside of it won't.
  TARGET_PATH_TO_MAFIA: ''
  
  
  
  # comma-separated list of (relative) path and name of the ASH scripts you want to bundle, and their new names and (relative) destinations.
  # Paths need to be relative to the "mafia folder".
  # Any .ash script not in this list won't be transferred, so if you have scripts that don't have imports, but want them in the result, include them here anyway
  
  # The scripts to bundle
  ASH_SCRIPT_SOURCES: 'relay/relay_TourGuide.ash'
  # Their (RESPECTIVE; order matters) destinations
  ASH_SCRIPT_DESTINATIONS: 'relay/relay_TourGuide.ash'



on: # customize at will
  workflow_dispatch:
  # for more info about this if you want to modify it, see
  # https://docs.github.com/en/free-pro-team@latest/actions/reference/workflow-syntax-for-github-actions#onpushpull_requestbranchestags
  # (for example, if you wish to make it so that any branch can trigger this workflow)
  push:
    branches:
      - 'master'
    paths:
      # MAKE SURE THIS IS UP-TO-DATE/CORRECT (it's impossible to query env. variables at this point).
      - 'Source/**.ash'
      - 'Source/**.js'
    # security measure: doesn't trigger if anything in .github was changed (such as the creation, modification or deletion of this very file)
      - '!.github/**'



# Anything past this point shouldn't need to be modified.

jobs:
  set-target-branch:
    runs-on: windows-latest
    outputs:
      target-branch: ${{ steps.set-target.outputs.target }}
    steps:
      - name: Get branch name
        uses: nelonoel/branch-name@v1.0.1
      
      - id: set-target
        run: |
          if ( "${{ env.USE_DYNAMIC_TARGET_NAME }}" -eq "true" ) {
            echo "::set-output name=target::${{ format( env.DYNAMIC_TARGET_NAME, env.BRANCH_NAME ) }}"
          } else {
            echo "::set-output name=target::${{ env.STATIC_TARGET_NAME }}"
          }
  
  build:
    runs-on: windows-latest
    needs: [set-target-branch]

    steps:
      - name: setup Python
        uses: actions/setup-python@v2
        with:
          python-version: 3.8
        
      # checkout source and target branches
      - name: checkout current branch
        uses: actions/checkout@v2
        with:
          path: source_branch
      
      - name: checkout target branch
        id: target_get
        uses: actions/checkout@v2
        continue-on-error: true
        with:
          ref: ${{ needs.set-target-branch.outputs.target-branch }}
          path: target_branch
          persist-credentials: false
          fetch-depth: 0
      
      # target branch doesn't exist; create it
      - name: create target branch
        id: target_create
        if: ${{ steps.target_get.outcome == 'failure' }}
        uses: peterjgrainger/action-create-branch@v2.0.1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          branch: ${{ needs.set-target-branch.outputs.target-branch }}
      
      # NOW checkout the newly-made target branch
      - name: checkout created target branch
        id: target_get_created
        if: ${{ steps.target_create.outcome == 'success' }}
        uses: actions/checkout@v2
        with:
          ref: ${{ needs.set-target-branch.outputs.target-branch }}
          path: target_branch
          persist-credentials: false
          fetch-depth: 0
      
      # Clean mafia folder in target branch
      - name: clean target branch
        working-directory: ./target_branch
        shell: python
        run: |
          import os
          import shutil
          
          target_base = '${{ env.TARGET_PATH_TO_MAFIA }}'
          if not os.path.exists( target_base ):
            os.makedirs( target_base )
          
          with os.scandir(target_base) as cur_dir:
            for dir_entry in cur_dir:
              if dir_entry.name != '.git':
                path_to_entry = os.path.join(target_base, dir_entry.name)
                if dir_entry.is_dir(follow_symlinks=False):
                  shutil.rmtree(path=path_to_entry)
                else:
                  os.remove(path=path_to_entry)
        
        
        
      - name: checkout bundler
        uses: actions/checkout@v2
        with:
          repository: fredg1/ASH-bundler
          path: bundler_branch
        
      - name: Forward bundle output to target branch
        id: bundle-ASH
        shell: python
        run: |
          import os
          import sys
          
          sys.path.append( os.path.join( os.getcwd(), 'bundler_branch' ) )
          import Bundle_ASH_script
          
          
          source_scripts = tuple( map(str, '${{ env.ASH_SCRIPT_SOURCES }}'.split(',') ) )
          destinations = tuple( map(str, '${{ env.ASH_SCRIPT_DESTINATIONS }}'.split(',') ) )
          
          if len(source_scripts) != len(destinations):
            raise Exception("ASH_SCRIPT_SOURCES and ASH_SCRIPT_DESTINATIONS aren't properly paired")
          
          imported_files = []
          bundled_files = []
          
          for i in range( len( source_scripts ) ):
            # The script that bundles the target script.
            # First argument is the source script.
            source_script = source_scripts[i]
            
            # Second argument is the path to reach the file to create/put the result in.
            destination = os.path.join( 'target_branch', '${{ env.TARGET_PATH_TO_MAFIA }}', destinations[i] )
            
            # Third argument (optional) is the path to reach the "mafia folder".
            path_to_source_script = os.path.join( 'source_branch', '${{ env.SOURCE_PATH_TO_MAFIA }}' )
            
            imports = Bundle_ASH_script.bundle_and_write( source_script, destination, path_to_source_script, allow_overwrite=True, return_imported_files=True )
            
            imported_files.extend( imports )
            bundled_files.append( source_script )
          
          print(f'::set-output name=imported_files::{imported_files}')
          print(f'::set-output name=bundled_files::{bundled_files}')
      
      # copy any non-ASH file in target_branch
      - name: Add non-ash in Source
        shell: python
        run: |
          import os
          
          source_base = os.path.join('source_branch', '${{ env.SOURCE_PATH_TO_MAFIA }}')
          target_base = os.path.join('target_branch', '${{ env.TARGET_PATH_TO_MAFIA }}')
          
          imported_files = ${{ steps.bundle-ASH.outputs.imported_files }}
          bundled_files = ${{ steps.bundle-ASH.outputs.bundled_files }}
          used_ASH_files = imported_files + bundled_files
          unused_ASH_files = []
          
          def parse_folder(cur_dir, current_path = ''):
            for dir_entry in cur_dir:
              if dir_entry.is_symlink():
                continue
              if dir_entry.is_dir():
                next_path = os.path.join(current_path, dir_entry.name)
                with os.scandir( os.path.join(source_base, next_path) ) as next_dir:
                  parse_folder(next_dir, next_path)
              elif dir_entry.is_file():
                if dir_entry.name.endswith('.ash'):
                  if used_ASH_files.count( dir_entry.name ) == 0:
                    unused_ASH_files.append( dir_entry.name )
                else:
                  this_path = os.path.join(current_path, dir_entry.name)
                  print('Grabbing ' + this_path + ' ...')
                  
                  this_path_source = os.path.join(source_base, this_path)
                  this_path_target = os.path.join(target_base, this_path)
                  if os.path.exists( this_path_target ):
                    os.remove( this_path_target )
                  os.renames(this_path_source, this_path_target)
          
          with os.scandir(source_base) as source_dir:
            parse_folder(cur_dir = source_dir)
          
          if len( unused_ASH_files ) > 0:
            print()
            print( len( unused_ASH_files ) + ' unused ASH file(s) found:' )
            for unused_file in unused_ASH_file:
              print( '    ' + unused_file )
      
      - name: commit changes to target
        working-directory: ./target_branch
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add --all -v *
          git commit -m "Import changes from ${{ github.ref }}" -a
          git push "https://${{ github.actor }}:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git" HEAD:refs/heads/${{ needs.set-target-branch.outputs.target-branch }} --follow-tags --tags
